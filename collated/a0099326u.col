//@author: a0099326u



	/**
	 * origin: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Command.cpp
	 */

#include "Command.h"

Command::Command() {

}

Command::~Command() {

}

bool Command::Add(Task userTask) {

	todoList.listToStack();
	log.log("Command: Adding new task");

	bool added = true;
	int counter = 0;
	Task temp;
	if(todoList.getSize() != 0) {
		while(counter < todoList.getSize()) {
			temp = todoList.accessSlot(counter);

			// Exception handling for same task. Throws exception if task already exists.
			if(temp.taskName == userTask.taskName && temp.startDate == userTask.startDate && temp.startTime == userTask.startTime && temp.endDate == userTask.endDate && temp.endTime == userTask.endTime) {
				added = false;
				break;
			}
			counter++;
		}
	}
	if(added) {
		int vectIndexOfNextTask = todoList.getSize();
	
		int newTaskID = issueNewTaskID();
		userTask.taskID = to_string(newTaskID);
		todoList.pushback(userTask);
	} else {
		todoList.undoUndoList();
	}
	sort();
	todoList.saveToFile();
	log.log("Command: New task added");
	return added; 
}

bool Command::Delete(Task userTask) {

	int size = todoList.getSize();
	// Asserts that the task ID is within the task list range.
	assert(stoi(userTask.taskID) <= size);

	todoList.listToStack();
	log.log("Command: Deleting task");
	
	bool erased = todoList.eraser(userTask.taskID);
	
	sort();
	todoList.saveToFile();
	log.log("Command: Task Deleted");

	return erased;
	
}

bool Command::Update(Task userTask, string updateField) {

	int size = todoList.getSize();
	// Asserts that the task ID is within the task list range.
	assert(stoi(userTask.taskID) <= size);

	todoList.listToStack();
	log.log("Command: Updating task");
	bool updated = false;
	int Index = 0;
	while(userTask.taskID != todoList.getTask(Index).taskID) {
		Index++;
	}
	try {
		updated = todoList.changeTaskPos(Index, userTask, updateField);
	} catch (string error) {
		throw error;
	}
	
	int counter = 0, sameTaskNum = 0;
	Task temp, copyUserTask;
	copyUserTask = todoList.getTask(Index);

	// Exeption Handling for updating to same task. Throws exception if task is updated to a task inside the list.
	if(updated) {
		while(counter < todoList.getSize()) {
			temp = todoList.accessSlot(counter);
			if(temp.taskName == copyUserTask.taskName && temp.startDate == copyUserTask.startDate && temp.startTime == copyUserTask.startTime && temp.endDate == copyUserTask.endDate && temp.endTime == copyUserTask.endTime) {
				sameTaskNum++;
			}
			counter++;
		}

		if(sameTaskNum > 1) {
			updated = false;
			undo();
			Delete(todoList.getTask(Index));
		}
	}

	sort();
	todoList.saveToFile();
	log.log("Command: Task updated");

	return updated;
}

bool Command::Search(string searchField, string searchItem) {
	log.log("Searching: Updating task");
	bool found = false;
	int counter = 0;
	found = todoList.searchItem(counter, searchField, searchItem);
	log.log("Command: Finished searching");

	return found;
}

Task Command::getTask(int Index) {

	int size = todoList.getSize();
	// Asserts that the Index is within the task list range.
	assert(Index < size);

	return todoList.getTask(Index);
}

int Command::issueNewTaskID(){
	
	int newIndex =  todoList.getSize();
	newIndex++;

	return newIndex;
}
 
vector<Task>* Command::getTaskList() { 
	todoList.markTasksDueToday();
	vector<Task>* list = new vector<Task>;
	*list = todoList.getTaskList();
	return list;
}

bool Command::markDone(Task task) {
	
	int size = todoList.getSize();
	// Asserts that the task ID is within the task list range.
	assert(stoi(task.taskID) <= size);
	
	todoList.listToStack();

	log.log("Command: task is being marked done");
	bool done = false;
	Task temp;
	int counter = 0;
	while(counter < todoList.getSize()) {
		temp = todoList.getTask(counter);
		if(temp.taskID == task.taskID) {
			temp.isDone = true;
			todoList.changeTaskPos(counter,temp);
			done = true;
			break;
		}
		counter++;
	}
	sort();
	todoList.saveToFile();
	return done;
}

bool Command::undo() {

	log.log("Command: undo");

	bool undone = true;
	todoList.stackToList();
	todoList.saveToFile();
	return undone;
}

vector<Task>* Command::getSearchedList() {
	vector<Task>* list = new vector<Task>;
	*list = todoList.getSearchedList();
	return list;
}

void Command::sort() {
	sortdone();
	int counter = 0;
	int size = todoList.getSize();
	if(size > 1) {
		while(counter < size) {
			if(!todoList.accessSlot(counter).isDone) {
				counter++;
			} else {
				break;
			}
		}
		sortDateAndTime(0, counter);
		sortDateAndTime(counter, todoList.getSize());

		todoList.updateTaskID();
	}

}

void Command::sortDateAndTime(int start, int end) {
	
	log.log("Command: sorting List");
	Task next;
	int Date, nextDate, j, i = start+1;
	while(i < end) {
		next = todoList.accessSlot(i);
		if(!next.startDate.empty()) {
			Date = stoi(next.startDate);
		} else {
			Date = 0;
		}
		j = i-1;
		
		if(!todoList.accessSlot(j).startDate.empty()) {
			nextDate = stoi(todoList.accessSlot(j).startDate);
		} else {
			nextDate = 0;
		}
		
		while(j >= start && nextDate > Date) {
			todoList.changeTaskPos(j+1, todoList.accessSlot(j));
			j--;
			if(j>=0) {
				if(!todoList.accessSlot(j).startDate.empty()) {
					nextDate = stoi(todoList.accessSlot(j).startDate);
				} else {
					nextDate = 0;
				}
			}
		}
		todoList.changeTaskPos(j+1, next);
		i++;
	}
	
	int Time, nextTime, prevSameDate, sameDate = 0, counter = start, countNum;
	
	while(sameDate < end) {
		prevSameDate = sameDate;
		next = todoList.getTask(sameDate);

		while((sameDate+1)<end) {
			if(next.startDate == todoList.getTask(sameDate+1).startDate)
				sameDate++;
			else
				break;
		}

		counter = prevSameDate+1;
		countNum = sameDate - prevSameDate;

		if(countNum>0) {
			for(int i = counter; i <= sameDate; i++) {
				next = todoList.accessSlot(i);
				if(!next.startTime.empty()) {
					Time = stoi(next.startTime);
				} else {
					Time = 0;
				}
				int j=i-1;
				if(!todoList.accessSlot(j).startTime.empty()) {
					nextTime = stoi(todoList.accessSlot(j).startTime);
				} else {
					nextTime = 0;
				}
				for(j = i-1; j >= prevSameDate && nextTime > Time; --j) {
					todoList.changeTaskPos(j+1, todoList.accessSlot(j));
					if(!todoList.accessSlot(j).startTime.empty()) {
						nextTime = stoi(todoList.accessSlot(j).startTime);
					} else {
						nextTime = 0;
					}
				}
				todoList.changeTaskPos(j+1, next);
			}
		}
		sameDate++;
	} 
	log.log("Command: List sorted");
}

void Command::sortdone() {
	int counter = 0;
	Task temp;
	stack<Task> doneTasks;
	vector<int> doneTasksIndex;

	while(counter < todoList.getSize()) {
		temp = todoList.accessSlot(counter);
		if(temp.isDone) {
			doneTasks.push(temp);
			doneTasksIndex.push_back(counter);
		}
		counter++;
	}
	while(!doneTasksIndex.empty()) {
		todoList.eraser(to_string(doneTasksIndex.back() + 1));
		doneTasksIndex.pop_back();
	}
	while(!doneTasks.empty()) {
		todoList.pushbackDoneTask(doneTasks.top());
		doneTasks.pop();
	}
}

vector<Task>* Command::getTodayTask() {
	
	int i;
	todoList.markTasksDueToday();
	int sizeofList = todoList.getSize();
	vector<Task>* tasksReturned = new vector<Task>;

	for( i = 0; i < todoList.getSize(); i++)
	{
		Task task = todoList.getTask(i);
		
		if(task.isBold == true && tasksReturned->size() < sizeofList )
		{
			tasksReturned->push_back(task);
		}

	}

	return tasksReturned;
}

vector<Task>* Command::getTomorrowTask() {
	
	int i;
	todoList.markTasksDueTomorrow();
	vector<Task>* tasksReturned = new vector<Task>;

	for( i = 0 ; i < todoList.getSize(); i++) {

		Task task = todoList.getTask(i);

		if(task.isTomorrow == true)
		{
			tasksReturned->push_back(task);
		}
	}

	return tasksReturned;
}

vector<Task>* Command::getOverdueTasks() {
	
	int i;
	todoList.markTasksOverdue();
	vector<Task>* tasksReturned = new vector<Task>;

	for( i = 0 ; i < todoList.getSize(); i++) {

		Task task = todoList.getTask(i);

		if(task.isRed == true)
		{
			tasksReturned->push_back(task);
		}
	}

	return tasksReturned;
}

vector<Task>* Command::getMarkedTasks() {

	vector<Task>* tasksReturned = new vector<Task>;

	for(int i = 0; i < todoList.getSize(); i++)
	{
		Task task = todoList.getTask(i);
		
		if(task.isDone ==  true) {

			tasksReturned->push_back(task);
		}
	}

	return tasksReturned;
}

vector<Task>* Command::getUnmarkedTasks() { 

	vector<Task>* tasksReturned = new vector<Task>;

	for(int i = 0; i < todoList.getSize(); i++)
	{
		Task task = todoList.getTask(i);
		
		if(task.isDone == false) {

			tasksReturned->push_back(task);
		}
	}

	return tasksReturned;

}

string Command::getSize() {
	string size = to_string(todoList.getSize());
	return size;
}

string Command::getTodayDay() {

	string toReturn =  todoList.currentDay();

	return toReturn;
}

string Command::getTodayMonth() {

	string toReturn =  todoList.currentMonth();

	return toReturn;
}

string Command::getTodayYear() {

	string toReturn =  todoList.currentYear();

	return toReturn;
}

vector<string> Command::getTomorrowDate() {

	vector<string> toReturn  = todoList.getDateTomorrow();

	return toReturn;
}
	// End of segment: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Command.cpp





	/**
	 * origin: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Command.h
	 */

// Command.h
/* Command contains all the functions to be executed on store (The task list).
 * It allows the manager to make changes to store through its functions.
 * 
 * Functions include:
 * 1. Editing the stored task list to execute user commands.
 * 2. Manage the task list and keep it organized.
 * 3. Getter functions to return pointers to the GUI.
 * Coded by Arun Kumar
*/
#ifndef COMMAND_H
#define COMMAND_H

#include "Headers.h"
#include "Store.h" 

using namespace std;

class Command {
private:
	//Member classes
	Store todoList;
	Log log;

	

public:
	Command();
	~Command();
	
	// Command functions

	// Adds the task to the task list
	bool Add(Task userTask);
	// Deletes the task from the task list
	bool Delete(Task userTask);
	// Searches for the item in the task list
	bool Search(string searchField, string searchItem);
	// Updates the task in the updatefield
	bool Update(Task userTask, string updateField);
	// Marks the task done in the task list
	bool markDone(Task task);
	// Removes the most recent change to the task list
	bool undo();
	// Sorts the task list according to the done tasks, start date and start time
	void sort();
	// Sorts the task list according to the start date and start time
	void sortDateAndTime(int start, int end);
	// Sorts the task list according to the done tasks
	void sortdone();
	
	// Display helper functions

	// Returns a pointer to the complete task list to GUI 
	vector<Task>* getTaskList();
	// Returns a pointer to the searched list to GUI
	vector<Task>* getSearchedList();
	// Returns a pointer to the tasks due today to GUI
	vector<Task>* getTodayTask();
	// Returns a pointer to the tasks due tomorrow to GUI
	vector<Task>* getTomorrowTask();
	// Returns a pointer to the overdue tasks to GUI
	vector<Task>* getOverdueTasks();
	// Returns a pointer to the done tasks to GUI
	vector<Task>* getMarkedTasks();
	// Returns a pointer to undone tasks to GUI
	vector<Task>* getUnmarkedTasks();
	
	// Getter functions

	// Returns the task to the function
	Task getTask(int Index);
	// Returns the size of the vector
	string getSize();
	// Issues a new task ID to the task
	int issueNewTaskID();
	// Returns the date of today
	string getTodayDay();
	// Returns the month of today
	string getTodayMonth();
	// Returns the year for today
	string getTodayYear();
	// Returns the date for tomorrow
	vector<string> getTomorrowDate();
};

#endif
	// End of segment: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Command.h





	/**
	 * origin: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Worker.h
	 */

// Worker.h
/* Worker receives the parsed command from the Parser through the Manager.
 * It excutes the commands from the user and returns the result to be displayed on the GUI.
 * 
 * Functions include:
 * 1. Identifying the parsed command and using the date provided by user accordingly.
 * 2. Executing the the commands by linking to store through Command class.
 * 3. Analysing the execution and returning the feedback to the GUI to be displayed.
 * Coded by Arun Kumar
*/


#include "Headers.h"
#include "Command.h"

using namespace std;

class Worker {
private:
	// Member Classes
	Command userCommand;
	Task userTask; 

	void convertTaskDataToDisplayFormat(vector<Task> &, bool shouldBeDetailed);
	 
	// Local variables used for functions
	string command;
	string updateField;
	string date;
	string month;
	string year;
	string store;
	string combine;

	string successful;
	string returnStringToMain;
	string stringToMain;
	string searchField;
	string searchItem;

	// Used to ensure data provided is correct
	bool continueNext;

public:

	Worker();
	~Worker();

	// Support functions

	// Takes the Parsed command, organizes the user data accordingly and returns
	// The feedback to be displayed on the GUI
	string takeParsedCommand(vector<string> fromManager);
	// Acts on the user command and executes the function
	string actOnCommand(string command);

	// Display helper functions

	// Returns a pointer to the complete task list to GUI
	vector<Task>* getTaskList();
	// Returns a pointer to the searched list to GUI
	vector<Task>* getSearchedList();
	// Returns a pointer to the tasks due today to GUI
	vector<Task>* getTasksDueTodayList();
	// Returns a pointer to the tasks due tomorrow to GUI
	vector<Task>* getTasksDueTomorrowList();
	// Returns a pointer to the overdue tasks to GUI
	vector<Task>* getTasksOverdueList();
	// Returns a pointer to the done tasks to GUI
	vector<Task>* getTasksDoneList();
	// Returns a pointer to undone tasks to GUI
	vector<Task>* getTasksUndoneList();

	vector<string> tomorrowDate;

	// Formatting functions

	// Formats the date to be displayed on GUI
	string formatDate(string, bool shouldShowYear, bool shouldBeDetailed);
	// Formats the time to be displayed on GUI
	string formatTime(string, bool shouldBeDetailed);
};



	// End of segment: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Worker.h





	/**
	 * origin: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Worker.cpp
	 */

/*  Worker cpp

Implementation for the worker class in which based on the
command entered by the user, the appropriate function is called to carry
out the desired operation.

*/
#include "Worker.h"
//const int NULL_DATE = -1;



// const string Parser::MESSAGE_DELETE = KEYWORD_DELETE;

Worker::Worker() {


}

Worker::~Worker() {
	//taskIndexIssuer;	// save the state of issuer pls
}


string Worker::takeParsedCommand(vector<string> parsedCommandstring) {

	continueNext = true;
	command =  parsedCommandstring[0];
	if(command == KEYWORD_ADD || command == KEYWORD_NEW || command == KEYWORD_CREATE ){

		if (parsedCommandstring[2] == KEYWORD_TODAY) {

			date = userCommand.getTodayDay();
			month = userCommand.getTodayMonth();
			year = userCommand.getTodayYear();
			combine = year + month + date;
			parsedCommandstring[2] = combine;

			userTask.taskName = parsedCommandstring[1];
			userTask.startDate = parsedCommandstring[2];
			userTask.startTime = parsedCommandstring[3];
			userTask.endDate = parsedCommandstring[4];
			userTask.endTime = parsedCommandstring[5];

		} else if (parsedCommandstring[2] == KEYWORD_TOMORROW_1 || parsedCommandstring[2] == KEYWORD_TOMORROW_2 || parsedCommandstring[4] == KEYWORD_TOMORROW_1 || parsedCommandstring[4] == KEYWORD_TOMORROW_2) {

			tomorrowDate = userCommand.getTomorrowDate();

			for (int i = tomorrowDate.size()-1; i >= 0 ; --i) {
				combine += tomorrowDate[i];

			}

			parsedCommandstring[2] = combine;
			parsedCommandstring[4] = combine;

			userTask.taskName = parsedCommandstring[1];
			userTask.startDate = parsedCommandstring[2];
			userTask.startTime = parsedCommandstring[3];
			userTask.endDate = parsedCommandstring[4];
			userTask.endTime = parsedCommandstring[5];

		} else {
		userTask.taskName = parsedCommandstring[1];
		userTask.startDate = parsedCommandstring[2];
		userTask.startTime = parsedCommandstring[3];
		userTask.endDate = parsedCommandstring[4];
		userTask.endTime = parsedCommandstring[5];

		}

		//Exception handler for start date and end date. Throws exception if end date is before the start date.
		if(!userTask.startDate.empty() && !userTask.endDate.empty()) {
			if(stoi(userTask.startDate) > stoi(userTask.endDate)) {
				continueNext = false;
			} else if(stoi(userTask.startDate) == stoi(userTask.endDate)) {
				if(!userTask.startTime.empty() && !userTask.endTime.empty() && stoi(userTask.startTime) > stoi(userTask.endTime)) {
					continueNext = false;
				}
			}
		} 


	} else if(command == KEYWORD_UPDATE || command == KEYWORD_EDIT || command == KEYWORD_CHANGE){
		//Exception Handler for taskID inserted. Throws exception is the taskID is outside the list range.
		if(!parsedCommandstring[1].empty()) {
			if(stoi(userCommand.getSize()) >= stoi(parsedCommandstring[1]) && stoi(parsedCommandstring[1]) > 0) {
				userTask.taskID = to_string(stoi(parsedCommandstring[1]));
			} else {
				continueNext = false;
			}
		} else {
			continueNext = false;
		}
		updateField = parsedCommandstring[2];

		//Exception handler for updateField. Throws exception if the field provided is unidentified.
		if(updateField == KEYWORD_TASK) {
			userTask.taskName = parsedCommandstring[3];

		} else if(updateField == KEYWORD_STARTDATE) {

			if (parsedCommandstring[3] == KEYWORD_TODAY) {

			date = userCommand.getTodayDay();
			month = userCommand.getTodayMonth();
			year = userCommand.getTodayYear();
			combine = year + month + date;
			parsedCommandstring[3] = combine;

			userTask.startDate = parsedCommandstring[3];
			

		} else if (parsedCommandstring[3] == KEYWORD_TOMORROW_1 || parsedCommandstring[3] == KEYWORD_TOMORROW_2) {

			tomorrowDate = userCommand.getTomorrowDate();

			for (int i = tomorrowDate.size()-1; i >= 0 ; --i) {
				combine += tomorrowDate[i];

			}

			parsedCommandstring[3] = combine;
			userTask.startDate = parsedCommandstring[3];
			


		} else {
		
			userTask.startDate = parsedCommandstring[3];
	
			}
		} else if(updateField == KEYWORD_STARTTIME) {
			userTask.startTime = parsedCommandstring[3];
		} else if(updateField == KEYWORD_ENDDATE) {

			if (parsedCommandstring[3] == KEYWORD_TODAY) {

			date = userCommand.getTodayDay();
			month = userCommand.getTodayMonth();
			year = userCommand.getTodayYear();
			combine = year + month + date;
			parsedCommandstring[3] = combine;

			userTask.endDate = parsedCommandstring[3];
			

		} else if (parsedCommandstring[3] == KEYWORD_TOMORROW_1 || parsedCommandstring[3] == KEYWORD_TOMORROW_2) {

			tomorrowDate = userCommand.getTomorrowDate();

			for (int i = tomorrowDate.size()-1; i >= 0 ; --i) {
				combine += tomorrowDate[i];

			}

			parsedCommandstring[3] = combine;
			userTask.endDate = parsedCommandstring[3];
			


		} else {
		
			userTask.endDate = parsedCommandstring[3];
	
			}

		} else if(updateField == KEYWORD_ENDTIME) {
			userTask.endTime = parsedCommandstring[3];
		} else {
			continueNext = false;
		}
	} else if(command == KEYWORD_DELETE || command == KEYWORD_DELETE) {
		//Exception Handler for taskID inserted. Throws exception is the taskID is outside the list range.
		if(stoi(userCommand.getSize()) >= stoi(parsedCommandstring[1]) && stoi(parsedCommandstring[1]) > 0) {
			userTask.taskID = parsedCommandstring[1];
		} else {
			continueNext = false;
		}
	} else if(command == KEYWORD_DONE || command == KEYWORD_DISPLAY || command == KEYWORD_VIEW) {
		//Exception Handler for taskID inserted. Throws exception is the taskID is outside the list range.
		if(stoi(userCommand.getSize()) >= stoi(parsedCommandstring[1]) && stoi(parsedCommandstring[1]) > 0) {
			userTask.taskID = to_string(stoi(parsedCommandstring[1]));
		} else {
			continueNext = false;
		}
	} else if(command == KEYWORD_SEARCH) {
		
		searchField = parsedCommandstring[1];
		searchItem = parsedCommandstring[2];
	}

	stringToMain.clear();

	if(command == KEYWORD_ADD) {
		stringToMain = STRING_QUOTE + userTask.taskName + STRING_QUOTE + SYSTEM_ENDL;
	} else if(continueNext) {
		if (!userTask.taskID.empty() && command != KEYWORD_UNDO) {
			int taskID = atoi(userTask.taskID.c_str()) - 1;
			Task task = userCommand.getTask(taskID); 
			stringToMain = STRING_QUOTE + task.taskName + STRING_QUOTE + SYSTEM_ENDL;
		}
	}
	try {
		stringToMain += actOnCommand(command);
	} catch (string error) {
		throw error;
	}

	return stringToMain;
}

string Worker::actOnCommand(string command)
{
	string startDate = userTask.startDate;
	string endDate = userTask.endDate;
	string startTime = userTask.startTime;
	string endTime = userTask.endTime;

	if(command == KEYWORD_ADD || command == KEYWORD_NEW || command == KEYWORD_CREATE) {
		if(continueNext == true && startDate != DAY_1 && endDate != DAY_1 && startDate != DAY_3 && endDate != DAY_3 && startDate != DAY_12 && endDate != DAY_12 && startDate != DAY_13 && endDate != DAY_13 && startDate != DAY_123 && endDate != DAY_123 && startTime != "0" && endTime != "0" )  {
			if(userCommand.Add(userTask)) {
				successful = MESSAGE_ADDED_SUCCESSFULLY;
			} else {
				successful = MESSAGE_ADDED_FAILED_TASK_IN_LIST;
			}
		
	//	} else if (startDate == DAY_1 || endDate == DAY_1 || startDate == DAY_3 || endDate == DAY_3 || startDate == DAY_12 || endDate == DAY_12 || startDate == DAY_13 || endDate == DAY_13 || startDate == DAY_123 || endDate == DAY_123 && (startTime == "0" || endTime == "0")) {
		//	successful = "Invalid Time and date!!! Task has not been added successfully! ): Type Carefully! \r\n";
		
		} else if (startDate == DAY_1 || endDate == DAY_1 ) {
			successful = MESSAGE_ADDED_FAILED_INVALID_DATE + MESSAGE_ADDED_FAILED;

		} else if (startDate == DAY_3 || endDate == DAY_3) {
			successful = MESSAGE_ADDED_FAILED_INVALID_YEAR + MESSAGE_ADDED_FAILED;
		
		} else if (startDate == DAY_12 || endDate == DAY_12) {
			successful = MESSAGE_ADDED_FAILED_INVALID_DATE_MONTH + MESSAGE_ADDED_FAILED;

		} else if (startDate == DAY_13 || endDate == DAY_13) {
			successful = MESSAGE_ADDED_FAILED_INVALID_DATE_YEAR + MESSAGE_ADDED_FAILED;

		} else if (startDate == DAY_123 || endDate == DAY_123) {
			successful = MESSAGE_ADDED_FAILED_INVALID_DATE_MONTH_YEAR + MESSAGE_ADDED_FAILED;

		} else if (startTime == TIME_0 || endTime == TIME_0) {
			successful = MESSAGE_ADDED_FAILED_INVALID_TIME + MESSAGE_ADDED_FAILED;
		} else {
			successful = MESSAGE_ADDED_FAILED_CHRONO_ORDER;
		}
	}

	else if(command == KEYWORD_DELETE || command == KEYWORD_DELETE) {
		if(continueNext == true) {
			if(userCommand.Delete(userTask) ) {
				successful = MESSAGE_DELETED_SUCCESSFULLY;
			}
			else {
				successful = MESSAGE_WRONG_INDEX;
			}
		} else {
			successful = MESSAGE_OUT_OF_RANGE_INDEX;
		}
	}


	else if(command == KEYWORD_UPDATE || command == KEYWORD_EDIT|| command == KEYWORD_CHANGE ) {
		if(continueNext == true) {
			if(startDate != DAY_1 && endDate != DAY_1 && startDate != DAY_3 && endDate != DAY_3 && startDate != DAY_12 && endDate != DAY_12 && startDate != DAY_13 && endDate != DAY_13 && startDate != DAY_123 && endDate != DAY_123 && startTime != TIME_0 && endTime != TIME_0 ) {
				bool updated;
				try {
					updated = userCommand.Update(userTask, updateField);
				} catch (string error) {
					throw error;
				}
				if(updated) {
					successful = MESSAGE_UPDATED_SUCCESSFULLY;
				} else {
					successful = MESSAGE_UPDATED_FAILED_DUPLICATE;
				}
		
			} else if (startDate == DAY_1 || endDate == DAY_1 ) {
				successful = MESSAGE_UPDATED_FAILED_INVALID_DATE + MESSAGE_UPDATED_FAILED;

			} else if (startDate == DAY_3 || endDate == DAY_3) {
				successful = MESSAGE_UPDATED_FAILED_INVALID_YEAR + MESSAGE_UPDATED_FAILED;
		
			} else if (startDate == DAY_12 || endDate == DAY_12) {
				successful = MESSAGE_UPDATED_FAILED_INVALID_DATE_MONTH + MESSAGE_UPDATED_FAILED;

			} else if (startDate == DAY_13 || endDate == DAY_13) {
				successful = MESSAGE_UPDATED_FAILED_INVALID_DATE_YEAR + MESSAGE_UPDATED_FAILED;

			} else if (startDate == DAY_123 || endDate == DAY_123) {
				successful = MESSAGE_UPDATED_FAILED_INVALID_DATE_MONTH_YEAR + MESSAGE_UPDATED_FAILED;

			} else if (startTime == TIME_0 || endTime == TIME_0) {
				successful = MESSAGE_UPDATED_FAILED_INVALID_TIME + MESSAGE_UPDATED_FAILED;
			} 
		} else {
			successful = MESSAGE_UPDATED_FAILED_OUT_OF_RANGE;
		}
		
	}

	else if(command == KEYWORD_SEARCH ) {
		bool found = userCommand.Search(searchField, searchItem);
		if(found) {
			successful = MESSAGE_SEARCH_SUCCESSFUL;
		}
		else {
			successful = MESSAGE_SEARCH_FAILED;
		}
	}

	else if(command == KEYWORD_DONE ) {
		if(continueNext == true) {
			bool found = userCommand.markDone(userTask);
			if(found) {
				successful = MESSAGE_DONE_SUCCESSFUL;
			}
			else {
				successful = MESSAGE_DONE_FAILED;
			}
		} else {
			successful = MESSAGE_OUT_OF_RANGE_INDEX;
		}
	}

	else if(command == KEYWORD_DISPLAY) {
		if(continueNext == true) {
			vector<Task>* taskList = new vector<Task>;
			taskList = userCommand.getTaskList();
			int intID = stoi(userTask.taskID) - 1;
			Task task = taskList->at(intID);
			bool shouldShowYear = true;
			bool shouldBeDetailed = false;

			successful = MESSAGE_DISPLAY_START + formatDate(task.startDate, shouldShowYear, shouldBeDetailed) + MESSAGE_DISPLAY_SPACE_FORMATTING + formatTime(task.startTime, shouldBeDetailed) + SYSTEM_ENDL +
						 MESSAGE_DISPLAY_END + formatDate(task.endDate, shouldShowYear, shouldBeDetailed) + MESSAGE_DISPLAY_SPACE_FORMATTING + formatTime(task.endTime, shouldBeDetailed) + SYSTEM_ENDL;
			delete taskList;
		} else {
			successful = MESSAGE_OUT_OF_RANGE_INDEX;
		}
	}

	else if(command ==  KEYWORD_UNDO) {
		if(userCommand.undo()) {
			successful = MESSAGE_UNDO_SUCCESSFUL;
		} else {
			successful = MESSAGE_UNDO_FAILED;
		}
	}
		

	return successful;

}

vector<Task>* Worker::getTaskList() {
	vector<Task>* displayedTaskList = userCommand.getTaskList();

	bool shouldShowEndTime = false;
	convertTaskDataToDisplayFormat(*displayedTaskList, shouldShowEndTime);

	return displayedTaskList;
}

vector<Task>* Worker::getSearchedList() {
	vector<Task>* displayedTaskList = userCommand.getSearchedList();

	bool shouldShowEndTime = false;
	convertTaskDataToDisplayFormat(*displayedTaskList, shouldShowEndTime);

	return displayedTaskList;
}

vector<Task>* Worker::getTasksDueTodayList() {

	vector<Task>* displayedTaskList =  userCommand.getTodayTask();
	
	bool shouldShowEndTime = true;
	convertTaskDataToDisplayFormat(*displayedTaskList, shouldShowEndTime);

	return displayedTaskList;
}

vector<Task>* Worker::getTasksDueTomorrowList() {

	vector<Task>* displayedTaskList = userCommand.getTomorrowTask();

	bool shouldShowEndTime = true;
	convertTaskDataToDisplayFormat(*displayedTaskList, shouldShowEndTime);

	return displayedTaskList;
}

vector<Task>* Worker::getTasksOverdueList() {

	vector<Task>* displayedTaskList =  userCommand.getOverdueTasks();

	bool shouldShowEndTime = false;
	convertTaskDataToDisplayFormat(*displayedTaskList, shouldShowEndTime);

	return displayedTaskList;

}

vector<Task>* Worker::getTasksDoneList() {

	vector<Task>* displayedTaskList =  userCommand.getMarkedTasks();

	bool shouldShowEndTime = false;
	convertTaskDataToDisplayFormat(*displayedTaskList, shouldShowEndTime);

	return displayedTaskList;
}

vector<Task>* Worker::getTasksUndoneList() {

	vector<Task>* displayedTaskList =  userCommand.getUnmarkedTasks();

	bool shouldShowEndTime = false;
	convertTaskDataToDisplayFormat(*displayedTaskList, shouldShowEndTime);

	return displayedTaskList;
}


void Worker::convertTaskDataToDisplayFormat(vector<Task> &taskList, bool shouldBeDetailed) { //, const bool& isExpanded) {
	for (int i = 0; i < (int) taskList.size(); ++i) {
		string taskIndex = taskList[i].taskID;
		string taskName = taskList[i].taskName;

		//limit taskName length for display
		if (taskName.size() > TASKLIST_NAME_LENGTH) {
			taskName = taskName.substr(0,TASKLIST_NAME_LENGTH-1);
			taskName += "...";
			taskList[i].taskName = taskName;
		}

		// 4 digit index display
		while (taskIndex.size() < TASKLIST_INDEX_LENGTH) {
			taskIndex = TASK_INDEX_FORMATTING + taskIndex;
		}
		taskList[i].taskID = taskIndex;
		
		// Worded date/time display
		bool shouldShowYear = false;
		taskList[i].startDate = formatDate(taskList[i].startDate, shouldShowYear, shouldBeDetailed);
		taskList[i].startTime = formatTime(taskList[i].startTime, shouldBeDetailed);
		taskList[i].endDate = formatDate(taskList[i].endDate, shouldShowYear, shouldBeDetailed);
		taskList[i].endTime = formatTime(taskList[i].endTime, shouldBeDetailed);
	}
}

string Worker::formatDate(string dataDate, bool shouldShowYear, bool shouldBeDetailed) {
	string sDate = dataDate;
	string sYear;
	string sMonth;
	string sDay;
	string resultDate;
	int date;
	int year;
	int month;
	int day;
	bool isKnownDateFormat = true;

	if (!sDate.empty() && sDate != DAY_0) {
			date = stoi(sDate);
			
			year = date/10000;
			sYear = " " + to_string(year);

			date %= 10000;
			month = date/100;
			//assert(1 <= month && month <= 12);
			switch (month) {
			case 1:
				sMonth = FORMAT_MONTH_1;
				break;
			case 2:
				sMonth = FORMAT_MONTH_2;
				break;
			case 3:
				sMonth = FORMAT_MONTH_3;
				break;
			case 4:
				sMonth = FORMAT_MONTH_4;
				break;
			case 5:
				sMonth = FORMAT_MONTH_5;
				break;
			case 6:
				sMonth = FORMAT_MONTH_6;
				break;
			case 7:
				sMonth = FORMAT_MONTH_7;
				break;
			case 8:
				sMonth = FORMAT_MONTH_8;
				break;
			case 9:
				sMonth = FORMAT_MONTH_9;
				break;
			case 10:
				sMonth = FORMAT_MONTH_10;
				break;
			case 11:
				sMonth = FORMAT_MONTH_11;
				break;
			case 12:
				sMonth = FORMAT_MONTH_12;
				break;
			default:
				isKnownDateFormat = false;
				break;
			}

			day = date%100;
			//assert(1 <= day && day <= 31);
			if (day < 10) {
				sDay = " " + to_string(day);
			} else {
				sDay = to_string(day);
			}

			if (isKnownDateFormat) {
				resultDate = sDay + sMonth;
				if (shouldShowYear) {
					resultDate += sYear;
				}
			} else {
				resultDate = NULL_STRING;
			}
		} else {
			if (shouldBeDetailed) {
				resultDate = TASK_EMPTY_TIME;
			}
		}
	return resultDate;
}

string Worker::formatTime(string sTime, bool shouldBeDetailed) {
	string time = sTime;
	string resultTime;
	bool isKnownTimeFormat = time.size() == 4;

	if (!time.empty() && time != TIME_0) {
		// Digital clock display
		//assert(time.size() <= 4);
		if (isKnownTimeFormat) {
			time.insert(2, TASK_TIME_FORMATTING);
			resultTime = time;
		} else {
			resultTime = NULL_STRING;
		}
	} else {
		if (shouldBeDetailed) {
			resultTime = TASK_EMPTY_TIME;
		}
	}
	return resultTime;
}































/*bool Worker::checkListForSlotFor(Task newTask){
for (iter = todoList.begin(); iter != todoList.end(); ++iter) {
if (iter->startDate < newTask.startDate && newTask.startDate < iter->endDate) {
return false;
}
if (iter->startTime < newTask.startTime && newTask.startTime < iter->endTime) {
return false;
}
if (iter->startDate < newTask.endDate && newTask.endDate < iter->endDate) {
return false;
}
if (iter->startTime < newTask.endTime && newTask.endTime < iter->endTime) {
return false;
}
}
return true;
}*/




	// End of segment: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\EasyDone\Worker.cpp





	/**
	 * origin: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\UnitTest\systemTest.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace systemTest {		
	TEST_CLASS(Easydone)
	{
	public:

		// system test
		// Partition test
		TEST_METHOD(systemTest1)
		{
			
			Manager test;
			Parser trial;
			Worker work;
			vector<Task> allTask;
			string sendToParser = "add gorilla's birthday on 12/12/14 10.00";

			vector<string> getfromParser = trial.completeParse(sendToParser);
			string getfromWorker = work.takeParsedCommand(getfromParser);

			string compare = "\"gorilla's birthday\"\r\nhas been added successfully! :) \r\n";

			/*test.receiveInput("add arun birthday on 12/12/14 10:00");
			allTask.clear();
			allTask = test.getAllTaskList();
			
			testTask.taskName = "arun birthday ";
			testTask.startDate = "12 Dec";
			testTask.startTime = "10:00";
			testTaskList.push_back(testTask);*/

			Assert::AreEqual(getfromWorker, compare);

			/*Assert::AreEqual((int)allTask.size(), (int) 1);
			Assert::AreEqual(allTask[0].taskName, testTaskList[0].taskName);*/
			//Assert::AreSame

			

		}

		// system test
		// boundary test: startDate
		TEST_METHOD(systemTestBoundaryDateCase)
		{
			
			Manager test;
			Parser trial;
			Worker work;
			vector<Task> allTask;
			string sendToParser = "add gorilla's birthday on 32/12/14 10.00";

			vector<string> getfromParser = trial.completeParse(sendToParser);
			string getfromWorker = work.takeParsedCommand(getfromParser);

			string compare = "\"gorilla's birthday\"\r\nInvalid date! Is it a 30th or 31st?? Ensure time format is correct too! =) \r\nTask has not been added successfully! ): ";

			/*test.receiveInput("add arun birthday on 12/12/14 10:00");
			allTask.clear();
			allTask = test.getAllTaskList();
			
			testTask.taskName = "arun birthday ";
			testTask.startDate = "12 Dec";
			testTask.startTime = "10:00";
			testTaskList.push_back(testTask);*/

			Assert::AreEqual(getfromWorker, compare);

			/*Assert::AreEqual((int)allTask.size(), (int) 1);
			Assert::AreEqual(allTask[0].taskName, testTaskList[0].taskName);*/
			//Assert::AreSame

			

		}

		// system test
		// boundary test: startDate for leap year
		TEST_METHOD(systemTestBoundaryDateCase2)
		{
			
			Manager test;
			Parser trial;
			Worker work;
			vector<Task> allTask;
			string sendToParser = "add gorilla's birthday on 29/2/16 10.00";

			vector<string> getfromParser = trial.completeParse(sendToParser);
			string getfromWorker = work.takeParsedCommand(getfromParser);

			string compare = "\"gorilla's birthday\"\r\nhas been added successfully! :) \r\n";

			/*test.receiveInput("add arun birthday on 12/12/14 10:00");
			allTask.clear();
			allTask = test.getAllTaskList();
			
			testTask.taskName = "arun birthday ";
			testTask.startDate = "12 Dec";
			testTask.startTime = "10:00";
			testTaskList.push_back(testTask);*/

			Assert::AreEqual(getfromWorker, compare);

			/*Assert::AreEqual((int)allTask.size(), (int) 1);
			Assert::AreEqual(allTask[0].taskName, testTaskList[0].taskName);*/
			//Assert::AreSame

			

		}

		// system test
		// boundary test: endtime & by
		TEST_METHOD(systemTestBoundaryDateCase3)
		{
			
			Manager test;
			Parser trial;
			Worker work;
			vector<Task> allTask;
			string sendToParser = "add gorilla's birthday by 28/2/15 00.00";

			vector<string> getfromParser = trial.completeParse(sendToParser);
			string getfromWorker = work.takeParsedCommand(getfromParser);

			string compare = "\"gorilla's birthday\"\r\nhas been added successfully! :) \r\n";

			/*test.receiveInput("add arun birthday on 12/12/14 10:00");
			allTask.clear();
			allTask = test.getAllTaskList();
			
			testTask.taskName = "arun birthday ";
			testTask.startDate = "12 Dec";
			testTask.startTime = "10:00";
			testTaskList.push_back(testTask);*/

			Assert::AreEqual(getfromWorker, compare);

			/*Assert::AreEqual((int)allTask.size(), (int) 1);
			Assert::AreEqual(allTask[0].taskName, testTaskList[0].taskName);*/
			//Assert::AreSame

			

		}

		// system test
		// boundary test: starttime 23.59
		TEST_METHOD(systemTestBoundaryDateCase4)
		{
			
			Manager test;
			Parser trial;
			Worker work;
			vector<Task> allTask;
			string sendToParser = "add gorilla's birthday on 28 apr 14 23.59";

			vector<string> getfromParser = trial.completeParse(sendToParser);
			string getfromWorker = work.takeParsedCommand(getfromParser);

			string compare = "\"gorilla's birthday\"\r\nhas been added successfully! :) \r\n";

			/*test.receiveInput("add arun birthday on 12/12/14 10:00");
			allTask.clear();
			allTask = test.getAllTaskList();
			
			testTask.taskName = "arun birthday ";
			testTask.startDate = "12 Dec";
			testTask.startTime = "10:00";
			testTaskList.push_back(testTask);*/

			Assert::AreEqual(getfromWorker, compare);

			/*Assert::AreEqual((int)allTask.size(), (int) 1);
			Assert::AreEqual(allTask[0].taskName, testTaskList[0].taskName);*/
			//Assert::AreSame

			

		}

		// system test
		// boundary test: from time boundary
		TEST_METHOD(systemTestBoundaryDateCase5)
		{
			
			Manager test;
			Parser trial;
			Worker work;
			vector<Task> allTask;
			string sendToParser = "add gorilla's birthday on the beach from 30 apr 14 00.01";

			vector<string> getfromParser = trial.completeParse(sendToParser);
			string getfromWorker = work.takeParsedCommand(getfromParser);

			string compare = "\"gorilla's birthday on the beach \"\r\nhas been added successfully! :) \r\n";

			/*test.receiveInput("add arun birthday on 12/12/14 10:00");
			allTask.clear();
			allTask = test.getAllTaskList();
			
			testTask.taskName = "arun birthday ";
			testTask.startDate = "12 Dec";
			testTask.startTime = "10:00";
			testTaskList.push_back(testTask);*/

			Assert::AreEqual(getfromWorker, compare);

			/*Assert::AreEqual((int)allTask.size(), (int) 1);
			Assert::AreEqual(allTask[0].taskName, testTaskList[0].taskName);*/
			//Assert::AreSame

			

		}
		// system test
		// boundary test: from time... to boundary for date
		TEST_METHOD(systemTestBoundaryDateCase6)
		{
			
			Manager test;
			Parser trial;
			Worker work;
			vector<Task> allTask;
			string sendToParser = "add gorilla's birthday by the beach from 30 apr 14 00.01 to 30 apr 14 12.00";

			vector<string> getfromParser = trial.completeParse(sendToParser);
			string getfromWorker = work.takeParsedCommand(getfromParser);

			string compare = "\"gorilla's birthday by the beach \"\r\nhas been added successfully! :) \r\n";

			/*test.receiveInput("add arun birthday on 12/12/14 10:00");
			allTask.clear();
			allTask = test.getAllTaskList();
			
			testTask.taskName = "arun birthday ";
			testTask.startDate = "12 Dec";
			testTask.startTime = "10:00";
			testTaskList.push_back(testTask);*/

			Assert::AreEqual(getfromWorker, compare);

			/*Assert::AreEqual((int)allTask.size(), (int) 1);
			Assert::AreEqual(allTask[0].taskName, testTaskList[0].taskName);*/
			//Assert::AreSame

			

		}

	};


}
	// End of segment: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\UnitTest\systemTest.cpp





	/**
	 * origin: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\UnitTest\testCommand.cpp
	 */

#include "stdafx.h"
#include "CppUnitTest.h"

using namespace Microsoft::VisualStudio::CppUnitTestFramework;

namespace workerTest {		
	TEST_CLASS(Easydone)
	{
	public:

/**********These tests check if the functions in Command class work successfully: ************
they are supposed to perform the CURD functions on the storage vector<Task> in Store class*/

		/*Tests if Add function in Command class successfully manages to Add a task to the storage vector */

		// Unit test: partition case
		TEST_METHOD(testCommandAddTaskName)
		{
			
			Command test;
			Task userTask;
			vector<Task> getList;
			userTask.taskName = "arun";
			userTask.startDate = "20141212";
			test.Add(userTask);
			

			getList = *test.getTaskList();

			vector<Task> testHardCase;
			Task testTask;
			testTask.taskName = "arun";
			testTask.startDate = "20141214";
			testHardCase.push_back(testTask);

			string test1 = getList[0].taskName;
			string test2 = testHardCase[0].taskName;
		
			Assert::AreEqual(test1, test2);
				
		}


		TEST_METHOD(testCommandddStartADate)
		{
			
			Command test;
			Task userTask;
			vector<Task> getList;
			userTask.taskName = "Arun";
			userTask.startDate = "20141212";
			test.Add(userTask);
			

			getList = *test.getTaskList();

			vector<Task> testHardCase;
			Task testTask;
			testTask.taskName = "Arun";
			testTask.startDate = "20141214";
			testHardCase.push_back(testTask);

			
			string test3 = getList[0].startDate;
			string test4 = testHardCase[0].startDate;
			
			
			Assert::AreNotEqual(test3, test4);
			
		}

		/*Unit test: if Delete function in Command class successfully manages to Delete a task in the storage vector
		while ensuring the tasks behind the deleted task get pushed forward by an index in the storage vector */

		TEST_METHOD(testCommandDelete)
		{
			
			Command test;
			Task userTask1;
			Task userTask2;
			vector<Task> getList;

			userTask1.taskName = "Arun";
			userTask1.taskID = "1";
			userTask1.startDate = "20141212";
			test.Add(userTask1);

			userTask2.taskName = "Daniel";
			userTask2.taskID = "2";
			userTask2.startDate = "20151212";
			test.Add(userTask2);
		
			test.Delete(userTask1);
		
			getList = *test.getTaskList();

			vector<Task> testHardCase;
			Task testTask;

			testTask.taskName = "Arun";
			testTask.startDate = "20141212";
			testHardCase.push_back(testTask);

			string test3 = getList[0].startDate;
			string test4 = testHardCase[0].startDate;
		
			Assert::AreNotEqual(test3, test4);
			
		}
	
	};
}

	// End of segment: C:\Users\Jiajun\Documents\Visual Studio 2012\Projects\EasyDone\UnitTest\testCommand.cpp





